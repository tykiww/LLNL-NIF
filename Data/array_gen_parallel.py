# Parallelized version of image generation code.
# Spreads out the computationally intensive portion of data preparation
# for simple usage with the BYU supercomputer


########################################################################################################################

# worker scripts for generating images directly frome a shape specification

# the functions in this script short cricuit the physics models in JAG. The user specifies a set of stagnation
# quantities directly and uses the ray-tracing routines in JAG to create images

########################################################################################################################

import numpy as np
import json
import tables
import datetime
import string
#import findspark
#findspark.init()
from pyspark.sql import SparkSession

#import sys
#sys.path.append('./jag')

from jag.implosion.implosion import implosion
from jag.implosion.build.splashapp import static_shot_params as shot_params, raytrace_kwargs
from jag.implosion.postprocess.images.make_image import xray_image

shot_params["betti_prl15_trans_u"] = 0.5
shot_params["betti_prl15_trans_v"] = 0.5

def build_stagnation_profile( ):

    """ Initialize the implosion instance

     Returns
     ---------------

     implo : jag.implosion.implosion instance
        the base implosion instance, defining various physics parameters to be used in the problem

     """

    implo = implosion( shot_params )

    return implo

def set_state_variables(implo, shape_modes={}, radius=30., pressure=500., temperature=5.):

    """ Define the state variables to be used in the ray trace

    Parameters
    ----------------------

    implo : jag.implosion.implosion instance
        An initialized implosiomn instance

    shape_modes : dict
        A dictionary of Ylm modes defining the shape of the outer surface of the hotspot, such that
        (x,y,z) = 2 * sqrt(pi) *
            ( sin(theta) cos(phi), sin(theta) sin(phi), cos(theta) ) *
            Sum[ shape_modes[(l,m)] spharm(l,m,theta,phi), {l=0,max), m=(-l,l) ]
        spharm uses the Laplace convention so the radius of the surface is in real units

    radius : float
        The radius of the image, ie, the first term in the spherical harmonic expansion (um)

    pressure : float
        The pressure of the emitting plasma (MBar)

    temperatre : float
        The temperature of the emitting plasma (KeV)

    Notes
    ----------------------------

    A call to this function appends the defined plasma state to the list of defined states in the implosion instance.
    A list of states to be processed by the image generation routine can be generated by repeated calls to this function

    """

    modes = { k:(v,0.,0.) for k,v in shape_modes.iteritems() }
    modes.update({ (0,0):(radius,0.,0.) })

    rn,rs,amps = implo.shape.calc_amps_from_modes(modes)
    drn, drs, damps = implo.shape.calc_amps_from_modes({})

    state_vector = [ pressure, temperature, temperature, radius, 100., radius, 100., 1.] + list( implo.shape.pack_vector(rn,rs,amps,drn,drs,damps))

    implo.cur_state.set_state_vector(state_vector)
    implo.cur_state.t = 1.

    implo.trajectory += (implo.cur_state,implo)
    implo.trajectory.finalize()

def make_xray_image(implo, line_of_sight, photon_energy=22., image_size_pixels=(100,100), image_size_microns=(100,100) ):

    """

    make xray images for all of the plasma states defined in the implosion instance, along the given line of sight

    Parameters
    ----------------------

    implo : jag.implosion.implosion instance
        An initialized implosiomn instance

    line_of_sight : tuple
        the (theta,phi) pair defining the line of sight of the image

    photon_energy : float
        photon energy of the image (KeV)

    image_size_pixels : tuple
        the number of pixels in the x and y directions of the image

    image_size_microns : tuple
        the size of the image in x and y directions (um)

    Returns
    -----------------------

    signals : list of ndarrays
        A list of generated images, one for each of the plasma states defined in the implosion instance

    """

    xpix = np.linspace( -image_size_microns[0]/2., image_size_microns[0]/2., image_size_pixels[0] )
    ypix = np.linspace(-image_size_microns[0] / 2., image_size_microns[0] / 2., image_size_pixels[0])

    imags = [ xray_image(implo,
                      image_time=[it],
                      image_photon_energy=photon_energy,
                      image_xpix=xpix,
                      image_ypix=ypix,
                      image_position=line_of_sight,
                      raytrace_kwargs=raytrace_kwargs )
              for it in range(1,len(implo.trajectory.t))]

    return [ imag["signal"] for imag in imags ]

########################################################################################################################


# Generate images in parallel then save all images to one hdf5 file

# Function defs for use in spark
def isComment(line):
	return any((char == '#') for char in line)

def cleanString(line):
	line = line.replace(',', ' ')
	line = line.replace('  ', ' ')
	return line

def createImage(line):
	amp = float(line[0])
	theta = float(line[1])
	phi = float(line[2])
	implo = build_stagnation_profile()
	set_state_variables(implo, shape_modes={(2, 0): amp})
	image = make_xray_image(implo, (theta, phi))
	image_name = "image_" + str(amp) + "_" + str(theta) + "_" + str(phi)
	description = "image_p_theta_phi created at " + str(datetime.datetime.now())
	result = {'p': amp, 'theta': theta, 'phi': phi, 'image': image, 'image_name': image_name, 'description': description}
	return result

# Spark code for simple parallelization of ray-tracing tasks
# Results are combined to one hdf5 file
def main():
	# Initialize spark
	spark = SparkSession.builder \
	   .master("local") \
	   .appName("LLNL implosion simulation BYU") \
	   .getOrCreate()

	spark.sparkContext.setLogLevel('WARN')
	sc = spark.sparkContext

	# Read lines, remove commas, pull out parameters, and create images
	lines = sc.textFile("input_params_parallel.txt")
	images = lines.filter(lambda line: not isComment(line)) \
					.map(cleanString) \
					.map(lambda line : line.split()) \
					.map(createImage)

	results = images.collect()

	# Create a new HDF5 file, and a 'group' within the file (for organization)
	h5file = tables.open_file("training_data.h5", mode="w", title="Training Data")
	group = h5file.create_group(h5file.root, 'images', 'Image information arrays')

	# Save images to file
	for result in results:
		array = h5file.create_array(group, result['image_name'], result['image'], result['description'])
		array.set_attr('p', result['p'])
		array.set_attr('theta', result['theta'])
		array.set_attr('phi', result['phi'])

	# Print the basic file structure and close file and spark
	print(h5file)
	h5file.close()
	spark.stop()

	return(0)

if __name__ == "__main__":
	main()
